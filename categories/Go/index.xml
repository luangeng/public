<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on 计算机与软件技术公开课</title>
    <link>https://luangeng.space/categories/Go/</link>
    <description>Recent content in Go on 计算机与软件技术公开课</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2018. All rights reserved.</copyright>
    <lastBuildDate>Mon, 09 Sep 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://luangeng.space/categories/Go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go 介绍</title>
      <link>https://luangeng.space/post/go/basic/info/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/info/</guid>
      <description>Go（又称Golang）是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。 罗伯特·格瑞史莫（Robert Gr</description>
    </item>
    
    <item>
      <title>Go 安装</title>
      <link>https://luangeng.space/post/go/basic/install/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/install/</guid>
      <description>Windows系统下安装和设置 安装 从 https://golang.org/dl/ 下载.msi包并运行即可 设置 安装完成后，您需要配置GOPATH环境变量。从Go 1.8开始，GOPATH</description>
    </item>
    
    <item>
      <title>Go基本数据类型</title>
      <link>https://luangeng.space/post/go/basic/basetype/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/basetype/</guid>
      <description>Booleans bool类型的值可以是true或false，初始为false var b bool = true fmt.Printf(&amp;quot;b is: &#39;%v&#39;\n&amp;quot;, b) b = false fmt.Printf(&amp;quot;b is: &#39;%v&#39;\n&amp;quot;, b) var b2 bool fmt.Printf(&amp;quot;zero value of bool is: &#39;%v&#39;\n&amp;quot;, b2) b is: &amp;lsquo;true&amp;rsquo; b is: &amp;lsquo;false&amp;rsquo; bool变量的</description>
    </item>
    
    <item>
      <title>Go 变量</title>
      <link>https://luangeng.space/post/go/basic/Variables/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Variables/</guid>
      <description>Go中声明变量有以下几种方式: // 声明单个顶层变量 var topLevel int64 = 5 // 组合声明多个变量 var ( intVal int // value is initialized with zero-value str string = &amp;quot;str&amp;quot; // assigning // functions are first-class values so can be assigned to variables // fn is variable of</description>
    </item>
    
    <item>
      <title>Go 常量</title>
      <link>https://luangeng.space/post/go/basic/Constants/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Constants/</guid>
      <description>Go支持character, string,boolean和数字型的常量. 常量基本使用: // Greeting 是public的string常量 const Greeting string = &amp;quot;Hello World&amp;quot; // 可以</description>
    </item>
    
    <item>
      <title>Go 字符串</title>
      <link>https://luangeng.space/post/go/basic/string/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/string/</guid>
      <description>go中的string是不可变的byte序列 Unlike languages like Python or Java, they are not internally represented as Unicode. Consequently, when reading strings from files or network connections, there is no conversion step from bytes to internal representation. When writing strings to files, there is no conversion to a code page. 与Pyt</description>
    </item>
    
    <item>
      <title>Go 指针</title>
      <link>https://luangeng.space/post/go/basic/Pointers/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Pointers/</guid>
      <description>指向变量的指针是该变量在内存中的地址。 Go不允许进行指针运算,不能在指针上增加或减少。 指针的零值为nil。 指针基础： v := 5 // pv is a pointer to v pv :=</description>
    </item>
    
    <item>
      <title>Go 数组</title>
      <link>https://luangeng.space/post/go/basic/array/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/array/</guid>
      <description>Go中的数组是相同类型元素的有序集合。数组的长度是固定不变的,不能扩展,因此比较少用.大部分情况下我们可以使用slice,它的长度可以扩大和</description>
    </item>
    
    <item>
      <title>Go slice类型</title>
      <link>https://luangeng.space/post/go/basic/slice/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/slice/</guid>
      <description>切片是相同类型的值的可增长序列。 其他语言称它们为数组或向量。 slice使用的内存由固定大小的数组提供。 切片是对该数组的视图。 切片具有长度和容</description>
    </item>
    
    <item>
      <title>Go map类型</title>
      <link>https://luangeng.space/post/go/basic/maps/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/maps/</guid>
      <description>map是无序的key-value对的集合. map的零值为nil map在其他语言中称为字典(C#, Python)或hash表(C++). map</description>
    </item>
    
    <item>
      <title>Go struct类型</title>
      <link>https://luangeng.space/post/go/basic/struct/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/struct/</guid>
      <description>struct的作用是将几个相关的变量组合成一个独立的实体. 另外,struct可以有方法,如同Java和C++中的类. 不同于Java和C++中</description>
    </item>
    
    <item>
      <title>Go 接口</title>
      <link>https://luangeng.space/post/go/basic/Interfaces/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Interfaces/</guid>
      <description>接口在类型上定义了一组方法。 接口用于抽象行为。 在Go中，接口只是一组方法。 我们使用接口来指定某个对象的行为。 例如：标准库中定义的io.Rea</description>
    </item>
    
    <item>
      <title>Go 判断</title>
      <link>https://luangeng.space/post/go/basic/if-switch-goto/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/if-switch-goto/</guid>
      <description>if 使用if进行基本的条件判断, 基本使用示例: a := 5 b := 6 if a == b { fmt.Print(&amp;quot;a is equal to b\n&amp;quot;) } else { fmt.Print(&amp;quot;a is not equal to b\n&amp;quot;) } a is not equal to b func returnValues(ok bool) (int, bool) { return 5, ok } func main() { a := 5</description>
    </item>
    
    <item>
      <title>Go 循环</title>
      <link>https://luangeng.space/post/go/basic/forwhileloops/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/forwhileloops/</guid>
      <description>Go中只有for循环,for循环的完整形式如下: for i := 0; i &amp;lt; 5; i += 2 { fmt.Printf(&amp;quot;i: %d\n&amp;quot;, i) } i: 0 i: 2 i: 4 for循环中的每个部分都不是必须的 比如没有初始化:</description>
    </item>
    
    <item>
      <title>Go range</title>
      <link>https://luangeng.space/post/go/basic/range-statement/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/range-statement/</guid>
      <description>遍历字符串 s := &amp;quot;Hey 世界&amp;quot; for i, r := range s { fmt.Printf(&amp;quot;idx: %d, rune: %d\n&amp;quot;, i, r) } idx: 0, rune: 72 idx: 1, rune: 101 idx: 2, rune: 121 idx: 3, rune: 32 idx: 4, rune: 19990 idx: 7, rune: 30028 请注意，范围假定字符串是UTF-</description>
    </item>
    
    <item>
      <title>Go 函数</title>
      <link>https://luangeng.space/post/go/basic/function/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/function/</guid>
      <description>基本函数示例: // addCheckOverflow adds two int16 numbers and additionally // returns true if the result overflowed func addCheckOverflow(a, b uint16) (uint16, bool) { res := a + b overflowed := res &amp;lt; a || res &amp;lt; b return res, overflowed } func main() { res, overflowed := addCheckOverflow(1, 3) fmt.Printf(&amp;quot;%5d + %5d = %5d, overflowed: %v\n\n&amp;quot;, 1, 3, res, overflowed) res, overflowed = addCheckOverflow(65520,</description>
    </item>
    
    <item>
      <title>Go 方法</title>
      <link>https://luangeng.space/post/go/basic/Methods/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Methods/</guid>
      <description>方法是绑定到类型的函数, 任何类型都可以绑定函数,但大多数情况下绑定到struct, 此时和Java或C++中的类相似 方法基本例子: type Person struct { FirstName string</description>
    </item>
    
    <item>
      <title>Go 错误处理</title>
      <link>https://luangeng.space/post/go/basic/Error-handling/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Error-handling/</guid>
      <description>基本错误处理: func sqrt(n float64) (float64, error) { if n &amp;lt; 0 { return 0, fmt.Errorf(&amp;quot;invalid argument &#39;%f&#39;, must be &amp;gt;= 0&amp;quot;, n) } return math.Sqrt(n), nil } func printSqrt(n float64) { if res, err := sqrt(n); err == nil { fmt.Printf(&amp;quot;sqrt of %f is %f\n&amp;quot;, n, res) } else { fmt.Printf(&amp;quot;sqrt of %f returned error &#39;%s&#39;\n&amp;quot;, n, err) } } func main() { printSqrt(16)</description>
    </item>
    
    <item>
      <title>Go Defer</title>
      <link>https://luangeng.space/post/go/basic/Defer/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Defer/</guid>
      <description>Defer In a complicated function, it’s easy to forgot to release a resource (e.g. to close a file handle or to unlock a mutex).
You can use defer statement to place code releasing a resource close to code that acquires the resource:
func foo() { f, err := os.Open(&amp;ldquo;myfile.txt&amp;rdquo;) if err != nil { return } defer f.Close()
// &amp;hellip; lots of code } In the above example, defer f.Close() ensures that f.</description>
    </item>
    
    <item>
      <title>Go Panic and recover</title>
      <link>https://luangeng.space/post/go/basic/Panic-and-recover/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Panic-and-recover/</guid>
      <description>This chapter assumes knowledge of defer.
In Go panic and recover are technically similar to exception handling in languages like C#, Java or Python.
panic is equivalent of throw or raise and recover fills the role of catch.
However, while those other languages often use exceptions as a way to propagate errors up the call chain, using panic in Go is highly discouraged.
It should only be used in truly exceptional cases.</description>
    </item>
    
    <item>
      <title>Go Concurrency</title>
      <link>https://luangeng.space/post/go/basic/Concurrency/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Concurrency/</guid>
      <description>Concurrency Go uses goroutines for concurrency. Simplifying, they are like threads.
Gorutines execute independently and share memory space.
Since they can write to the same memory, care needs to be taken when writing to the same global variables from multiple goroutines.
To coordinate work between goroutines Go provides channels, which are thread-safe queues.
Here’s an example of using worker pool of goroutines and coordinating their work with channels:
var wg sync.</description>
    </item>
    
    <item>
      <title>Go channel和select</title>
      <link>https://luangeng.space/post/go/basic/Channels-and-select/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Channels-and-select/</guid>
      <description>Channels and select A channel is a thread-safe queue of values of a given type. A primary use for channels is to communicate between goroutines. For that reason we talk about sending values to a channel (ch &amp;lt;- value) and receiving values from a channel (value &amp;lt;- ch). Basic of channels: func genInts(chInts chan int) { chInts &amp;lt;- rand.Intn(1000) } func main() { chInts := make(chan int) for i :=</description>
    </item>
    
    <item>
      <title>Go Mutex</title>
      <link>https://luangeng.space/post/go/basic/Mutex/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Mutex/</guid>
      <description>Mutex In Go goroutines share memory.
It’s good for performance but modifying the same memory from multiple goroutines is not safe. It can lead to data races and crashes.
One way to avoid that is by using channels to transfer exclusive ownership of data.
This is Go’s motto: do not communicate by sharing memory; instead, share memory by communicating.
Another way to ensure exclusive access to data by goroutines is to use mutexes.</description>
    </item>
    
    <item>
      <title>Go 包管理</title>
      <link>https://luangeng.space/post/go/basic/Packages/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Packages/</guid>
      <description>Go中的包代表了相关联的代码的单位,在其他语言中经常称为库. 包由一个目录下的多个文件组成.这个目录和包是一对一映射的. 一个仓库中可以包含多个</description>
    </item>
    
    <item>
      <title>Go 文件和I/O</title>
      <link>https://luangeng.space/post/go/basic/fileIO/</link>
      <pubDate>Sun, 08 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/fileIO/</guid>
      <description>Go对文件操作的支持很健壮. 下面的程序打开,读取并关闭了一个文件: path := &amp;quot;main.go&amp;quot; f, err := os.Open(path) if err != nil { log.Fatalf(&amp;quot;os.Open() failed with %s\n&amp;quot;, err) } defer f.Close() d, err := ioutil.ReadAll(f) if err != nil { log.Fatalf(&amp;quot;ioutil.ReadAll() failed with &#39;%s&#39;\n&amp;quot;, err) } lines :=</description>
    </item>
    
    <item>
      <title>Go 日期和时间</title>
      <link>https://luangeng.space/post/go/basic/Time-and-date/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Time-and-date/</guid>
      <description>Go时间包提供了处理时间和日期的功能。 包中的主要类型： structure time.Time represents time and date values time.Duration represents difference between two time.Time values in nanoseconds time.Second, time.Millisecond etc. are constants of time.Duration that are easier to use than nanoseconds 获取当前日期和时间: now := time.Now()</description>
    </item>
    
    <item>
      <title>Go Command line arguments</title>
      <link>https://luangeng.space/post/go/basic/Command-line-arguments/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Command-line-arguments/</guid>
      <description>标准库中的软件包标志用于解析命令行参数： var ( flgHelp bool flgEcho string ) func parseCmdLineFlags() { flag.BoolVar(&amp;amp;flgHelp, &amp;quot;help&amp;quot;, false, &amp;quot;if true, show help&amp;quot;) flag.StringVar(&amp;amp;flgEcho, &amp;quot;echo&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;&amp;quot;) flag.Parse() } func main() { parseCmdLineFlags() if flgHelp { flag.Usage() os.Exit(0) } fmt.Printf(&amp;quot;flag -echo: &#39;%s&#39;\n&amp;quot;, flgEcho) remainingArgs := flag.Args() for _, arg := range remainingArgs { fmt.Printf(&amp;quot;Remainig arg: &#39;%s&#39;\n&amp;quot;,</description>
    </item>
    
    <item>
      <title>Go 日志</title>
      <link>https://luangeng.space/post/go/basic/Logging/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Logging/</guid>
      <description>日志记录是一个非常深入的主题，因为不同的程序具有不同的日志记录要求。 使用fmt.Printf 和 fmt.Fprintf打印日志 日志的一种简单方</description>
    </item>
    
    <item>
      <title>Go 执行命令</title>
      <link>https://luangeng.space/post/go/basic/Executing-commands/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Executing-commands/</guid>
      <description>标准库中的Package exec是一种跨平台的方式来启动流程，捕获其输出以及更多。 基本命令执行 最简单的用法是：使用exec.Command（</description>
    </item>
    
    <item>
      <title>Go Hex和 base64编码</title>
      <link>https://luangeng.space/post/go/basic/Hex-base64-encoding/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Hex-base64-encoding/</guid>
      <description>有时候你需要将bytes编码非文本text. Most popular encodings are hex, where each byte is represented by 2 characters and base64 where each 3 bytes are encoded as 4 characters. Hex编码和解码 我们可以把[]byte编码为st</description>
    </item>
    
    <item>
      <title>Go JSON</title>
      <link>https://luangeng.space/post/go/basic/JSON/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/JSON/</guid>
      <description>encoding/json包是Go的标准库,提供JSON格式的序列化和反序列化功能. 序列化struct为JSON type Person struct { fullName string Name string Age int `json:&amp;quot;age&amp;quot;` City string `json:&amp;quot;city&amp;quot;`</description>
    </item>
    
    <item>
      <title>Go XML</title>
      <link>https://luangeng.space/post/go/basic/XML/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/XML/</guid>
      <description>Package encoding/xml in standard library provides functionality for serializing data as XML and parsing XML.
Parse XML into a struct Parsing XML is similar to parsing JSON. You define structures that map to the structure of XML and unmarshal from []byte slice or io.Reader into a struct.
var xmlStr = ` JohnSan FranciscoCA&amp;lt;person age=&amp;quot;23&amp;quot;&amp;gt; &amp;lt;first-name&amp;gt;Julia&amp;lt;/first-name&amp;gt; &amp;lt;/person&amp;gt;  `
type People struct { Person []Person xml:&amp;quot;person&amp;quot; }
type Person struct { Age int xml:&amp;quot;age,attr&amp;quot; FirstName string xml:&amp;quot;first-name&amp;quot; Address Address xml:&amp;quot;address&amp;quot; }</description>
    </item>
    
    <item>
      <title>Go CSV</title>
      <link>https://luangeng.space/post/go/basic/CSV/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/CSV/</guid>
      <description>标准库中的encoding/csv包提供了用于读取和写入CSV文件的功能。 从CSV文件读取记录 让我们从CSV文件中读取股票报价： date,open,high,low,close,volume,Name 2013-02-08,15.07,15.12,14.63,14.75,8407500,AAL 2013-02-11,14.89,15.01,14.26,14.46,8882000,AAL 2013-02-12,14.45,14.51,14.1,14.27,8126000,AAL 2013-02-13,14.3,14.94,14.25,14.66,10259500,AAL buf</description>
    </item>
    
    <item>
      <title>Go YAML</title>
      <link>https://luangeng.space/post/go/basic/YAML/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/YAML/</guid>
      <description>YAML是一种流行的格式，用于以人类友好的格式序列化数据, 类似JSON但更易于阅读。 由于其表达能力和可读性，YAML作为配置文件的格式很受欢</description>
    </item>
    
    <item>
      <title>Go SQL</title>
      <link>https://luangeng.space/post/go/basic/SQL/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/SQL/</guid>
      <description>备注 有关SQL数据库驱动程序的列表，请参见Go Wiki官方文章SQLDrivers。 SQL驱动程序被导入并以_作为前缀，因此它们仅可用于驱动</description>
    </item>
    
    <item>
      <title>Go HTTP Client</title>
      <link>https://luangeng.space/post/go/basic/HTTP-Client/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/HTTP-Client/</guid>
      <description>Package net/http in standard library provides functionality to make HTTP network requests.
In the examples we use httpbin.org which is a clever service that can return specific HTTP responses, which is useful for demonstrating various aspects of HTTP protocol.
Basic HTTP GET For simplicity this example uses http.Get(). In real programs you should use custom client with a timeout as described below.
uri := &amp;ldquo;https://httpbin.org/html&amp;quot; resp, err := http.Get(uri) if err !</description>
    </item>
    
    <item>
      <title>Go HTTP Server</title>
      <link>https://luangeng.space/post/go/basic/HTTP-Server/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/HTTP-Server/</guid>
      <description>http.ServeMux provides a multiplexer which calls handlers for HTTP requests. Alternatives to the standard library multiplexer include:
Gorilla Mux
Hello World The typical way to begin writing web servers in Go is to use the standard library net/http module.
There is also a tutorial for it here.
The following code also uses it. Here is the simplest possible HTTP server implementation. It responds &amp;ldquo;Hello World&amp;rdquo; to any HTTP request.
Save the following code in a server.</description>
    </item>
    
    <item>
      <title>Go HTTP server middleware</title>
      <link>https://luangeng.space/post/go/basic/HTTP-server-middleware/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/HTTP-server-middleware/</guid>
      <description>Introduction In Go Middleware can be used to execute code before and after handler function. It uses the power of Single Function Interfaces. Can be introduced at any time without affecting the other middleware. For Ex: Authentication logging can be added in later stages of development without disturbing the existing code.
Remarks The Signature of middleware should be (http.ResponseWriter, *http.Request) i.e. of http.handlerFunc type.
Normal Handler Function func loginHandler(w http.ResponseWriter, r *http.</description>
    </item>
    
    <item>
      <title>Go Text和HTML模板</title>
      <link>https://luangeng.space/post/go/basic/Text-and-HTML-templates/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Text-and-HTML-templates/</guid>
      <description>Imagine you’re working on a web application and need to return HTML that lists most recent tweets. You need to load list of tweets from a database and create HTML based on that information. Building that HTML string by building smaller strings and concatenating them with + would be tedious. Packages text/template and html/template in Go standard library make implement data-driven templates for generating textual</description>
    </item>
    
    <item>
      <title>Go 反射</title>
      <link>https://luangeng.space/post/go/basic/Reflection/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Reflection/</guid>
      <description>Reflection Go is a statically typed language. In most cases the type of a variable is known at compilation time. One exception is interface type, especially empty interface interface{}. Empty interface is a dynamic type, similar to Object in Java or C#. At compilation time we can’t tell if the underlying value of interface type is an int or a string. Package reflect in standard library</description>
    </item>
    
    <item>
      <title>Go Context</title>
      <link>https://luangeng.space/post/go/basic/Context/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Context/</guid>
      <description>Package context in standard library provides type Context which is hard to explain because it has multiple uses.
Here are the most common uses of context.Context:
context with timeout (deadline) is a generic way to implement timeouts for functions that can possibly take a long time where we want an option to abort them if they exceed the timeout context with cancellation is a generic way to cancel a goroutine context with value is a way to associate arbitrary value with a context Creating a context In most cases you’ll be calling existing API that requires context.</description>
    </item>
    
    <item>
      <title>Go 测试</title>
      <link>https://luangeng.space/post/go/basic/Testing/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Testing/</guid>
      <description>Go comes with its own testing facilities that has everything needed to run tests and benchmarks. Unlike in most other programming languages, there is often no need for a separate testing framework, although some exist. 基本使用 main.go: package main import ( &amp;quot;fmt&amp;quot; ) func main() { fmt.Println(Sum(4,5)) } func Sum(a, b int) int { return a + b } main_test.go: package main import ( &amp;quot;testing&amp;quot; ) //</description>
    </item>
    
    <item>
      <title>Go Calling C from GO with cgo</title>
      <link>https://luangeng.space/post/go/basic/Calling-C-from-GO-with-cgo/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Calling-C-from-GO-with-cgo/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Go 使用Go工具pprof进行性能分析</title>
      <link>https://luangeng.space/post/go/basic/Profiling-using-go-tool-pprof/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Profiling-using-go-tool-pprof/</guid>
      <description>基本的cpu和内存分析 在主程序中添加以下代码。 var cpuprofile = flag.String(&amp;quot;cpuprofile&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;write cpu profile `file`&amp;quot;) var memprofile = flag.String(&amp;quot;memprofile&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;write memory profile to `file`&amp;quot;) func main() { flag.Parse() if *cpuprofile != &amp;quot;&amp;quot; { f, err := os.Create(*cpuprofile) if err != nil { log.Fatal(&amp;quot;could not create CPU profile: &amp;quot;, err) } if err</description>
    </item>
    
    <item>
      <title>Go 交叉编译</title>
      <link>https://luangeng.space/post/go/basic/Cross-compilation/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Cross-compilation/</guid>
      <description>Cross compilation Introduction Go compiler can create native executable binaries for many operating system: Windows, Mac OS X, Linux, Android, iOS and a few lesser known like plan9, solaris, freebsd, openbsd, netbsd, dragonfly. It also supports multiple architectures (CPUs) for the same operating system e.g. it can generate both 32-bit and 64-bit Windows binaries or intel, arm, ppc, mips Linux binaries. Better yet, the toolchain supports cross-compilation i.e. you can</description>
    </item>
    
    <item>
      <title>Go 使用构建标签进行条件编译</title>
      <link>https://luangeng.space/post/go/basic/Conditional-compilation-with-build-tags/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Conditional-compilation-with-build-tags/</guid>
      <description>Conditional compilation with build tags Build tags allow for limited conditional compilation i.e. compiling different versions of code based on some criteria. Tags are specified per file, at the top of the file, followed by an empty line and the code. A typical use case for tags is to provide to implementation of the same functionality and pick the one that is compiled with tags. For example, if you have</description>
    </item>
    
    <item>
      <title>Go Inlining functions</title>
      <link>https://luangeng.space/post/go/basic/Inlining-functions/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Inlining-functions/</guid>
      <description>Inlining functions Function inlining is a common compiler optimization for improving performance of the code.
Small, frequently called functions can be directly included (inlined) in the body of the calling function. This eliminate function calling overhead.
Go compiler doesn&amp;rsquo;t provide a way to force inlining of functions.
Go compiler makes inlining decisions based on a number of heuristics.
Here&amp;rsquo;s an incomplete list of attributes that disable inlining:
functions are variadic (eg.</description>
    </item>
    
    <item>
      <title>Go sync.Pool for better performance</title>
      <link>https://luangeng.space/post/go/basic/sync.Pool-for-better-performance/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/sync.Pool-for-better-performance/</guid>
      <description>Allocating and freeing objects with high frequency can be relatively expensive.
A common technique for improving performance is re-using memory.
sync.Pool is a thread-safe cache for re-using allocations.
package main
import ( &amp;ldquo;bytes&amp;rdquo; &amp;ldquo;fmt&amp;rdquo; &amp;ldquo;sync&amp;rdquo; )
var pool = sync.Pool{ // New creates an object when the pool has nothing available to return. // New must return an interface{} to make it flexible. You have to cast // your type after getting it.</description>
    </item>
    
    <item>
      <title>Go gob</title>
      <link>https://luangeng.space/post/go/basic/gob/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/gob/</guid>
      <description>gob Gob is a Go specific serialization method created mostly for RPC (Remote Procedure Call).
It supports all Go data types except for channels and functions.
Gob writes type information in serialized data.
It&amp;rsquo;s a binary format so it&amp;rsquo;s more efficient than JSON or XML.
The inclusion of type information makes encoding and decoding robust to differences between encoder and decoder.
Encode data to file and decode from file type User struct { Username string Password string }</description>
    </item>
    
    <item>
      <title>Go 插件</title>
      <link>https://luangeng.space/post/go/basic/Plugin/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Plugin/</guid>
      <description>Go提供了一种插件机制，可用于在运行时动态链接其他Go代码。 在Go1.8中，仅在Linux上可用。 定义和使用插件 package main import &amp;quot;fmt&amp;quot; var V int func F() { fmt.Printf(&amp;quot;Hello, number %d\n&amp;quot;, V)</description>
    </item>
    
    <item>
      <title>Go fmt包</title>
      <link>https://luangeng.space/post/go/basic/Package-fmt/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Package-fmt/</guid>
      <description>标准库中的fmt包可以格式化字符串和从字符串中解析数据. 基本的fmt 包fmt使用格式动词实现格式化的I/O： %v 默认格式 %T 值的类型 %s 字符串或片</description>
    </item>
    
    <item>
      <title>Go Protobuf in Go</title>
      <link>https://luangeng.space/post/go/basic/Protobuf-in-Go/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Protobuf-in-Go/</guid>
      <description>介绍 Protobuf或协议缓冲区对数据进行编码和解码，以便以不同语言编写的不同应用程序或模块可以快速而可靠地交换大量消息，而不会导致通信通道</description>
    </item>
    
    <item>
      <title>Go Console I/O</title>
      <link>https://luangeng.space/post/go/basic/Console-IO/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Console-IO/</guid>
      <description>Console I/O When writing command-line programs, you can read user input from os.Stdin using any function that accepts io.Reader.
fmt.Scanf to read from stdio Most convenient way is to use fmt.Scanf which is a mirror image of fmt.Printf.
Here&amp;rsquo;s how to read a string and an integer from the console (standard input)
fmt.Print(&amp;ldquo;What is your name?\n&amp;rdquo;) var name string if n, err := fmt.Scanf(&amp;quot;%s&amp;rdquo;, &amp;amp;name); err != nil { fmt.Printf(&amp;ldquo;fmt.Scanf failed with &amp;lsquo;%s&amp;rsquo;\n&amp;rdquo;, err) } else { fmt.</description>
    </item>
    
    <item>
      <title>Go Cryptography</title>
      <link>https://luangeng.space/post/go/basic/Cryptography/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Cryptography/</guid>
      <description>介绍 了解如何使用Go加密和解密数据。 请记住，这不是一门关于密码学的课程，而是一门用Go语言实现的课程。 使用AES GCM进行加密和解密 您有一个</description>
    </item>
    
    <item>
      <title>Go Images</title>
      <link>https://luangeng.space/post/go/basic/Images/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Images/</guid>
      <description>Images (PNG, JPEG, BMP, TIFF, WEBP, VP8, GIF) Standard library provides the foundation for working with images.
Package image provides:
an image.Image interface describing a bitmap image an implementation for most common ways of representing an image in memory, for example Image.RGBA a way to register image format decoders (e.g. PNG, JPEG etc. with image.RegisterFormat. Standard library provides:
GIF decoder and encoder PNG decoder and encoder JPEG decoder and encoder The are libraries for:</description>
    </item>
    
    <item>
      <title>Go 命令</title>
      <link>https://luangeng.space/post/go/basic/Command/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://luangeng.space/post/go/basic/Command/</guid>
      <description>go命令是一个命令行程序，用于管理Go开发。 它支持构建，运行和测试代码，以及各种其他与Go相关的任务。 go fmt 为了保持代码的一致性并消除代码格式</description>
    </item>
    
  </channel>
</rss>