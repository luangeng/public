<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on IT从业者互助会</title>
    <link>https://wawazhua.cn/tags/Java/</link>
    <description>Recent content in Java on IT从业者互助会</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2018. All rights reserved.</copyright>
    <lastBuildDate>Sat, 03 Sep 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://wawazhua.cn/tags/Java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>两个线程交替打印奇数和偶数</title>
      <link>https://wawazhua.cn/post/java/basic/oddeven/</link>
      <pubDate>Sat, 03 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/oddeven/</guid>
      <description>两个线程交替打印奇数和偶数，即一个线程打印奇数，另一个打印偶数，交替打印从1到100,即: 奇 1 偶 2 奇 3 偶 4 奇 5 偶 6 奇 7 偶 8 奇 9 偶 10 解法一: w</description>
    </item>
    
    <item>
      <title>线程死锁</title>
      <link>https://wawazhua.cn/post/java/basic/deadlock/</link>
      <pubDate>Sat, 03 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/deadlock/</guid>
      <description>会导致死锁的代码: public class DeadLock extends Thread { private Object lock1; private Object lock2; public DeadLock(Object o1, Object o2) { this.lock1 = o1; this.lock2 = o2; } public void run() { synchronized (lock1) { try { TimeUnit.MILLISECONDS.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (lock2) { Q.p(&amp;quot;end&amp;quot;); } } } public static void main(String[] args) { Object o1 = new Object(), o2</description>
    </item>
    
    <item>
      <title>Java动态代理</title>
      <link>https://wawazhua.cn/post/java/basic/java-proxy/</link>
      <pubDate>Thu, 26 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-proxy/</guid>
      <description>代理模式:为某些对象提供代理以实现对这个对象的访问。 对一个对象进行访问控制的原因是为了只有在我们确实需要这个对象时才对它进行创建和初始化。 一</description>
    </item>
    
    <item>
      <title>Java基础--NIO</title>
      <link>https://wawazhua.cn/post/java/basic/java-nio/</link>
      <pubDate>Sat, 21 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-nio/</guid>
      <description>NIO库在JDK1.4中引入，它以标准Java代码提供了高速的，面向块的IO，弥补了之前同步IO的不足。 缓冲区Buffer Buffers是一</description>
    </item>
    
    <item>
      <title>Java并发--CountDownLatch CyclicBarrier ReentrantLock</title>
      <link>https://wawazhua.cn/post/java/basic/java-locks/</link>
      <pubDate>Fri, 20 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-locks/</guid>
      <description>CountDownLatch CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。CountDownLatch</description>
    </item>
    
    <item>
      <title>Java--两个线程交替执行和死锁</title>
      <link>https://wawazhua.cn/post/java/basic/java-oddeven/</link>
      <pubDate>Thu, 19 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-oddeven/</guid>
      <description>今天看到一个题:两个线程交替打印奇数和偶数，即一个线程打印奇数，另一个打印偶数，交替打印从1到100。想了下有多重实现方法。 wait和not</description>
    </item>
    
    <item>
      <title>Java基础--JDBC</title>
      <link>https://wawazhua.cn/post/java/basic/java-jdbc/</link>
      <pubDate>Wed, 18 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-jdbc/</guid>
      <description>JDBC(Java Database Connectivity) Java数据库连接，提供了一种与平台无关的用于执行SQL语句的标准javaAPI，可以方便实现多种关系型数据库的统一操作 常用的类与接口</description>
    </item>
    
    <item>
      <title>Java基础--注解Annotation</title>
      <link>https://wawazhua.cn/post/java/basic/java-annotation/</link>
      <pubDate>Tue, 17 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-annotation/</guid>
      <description>Annotation是给类，方法或域上加的一种特殊的标记，可以通过反射取到注解的类型和值，从而完成某种特定的操作。 定义注解需要使用元注解，元</description>
    </item>
    
    <item>
      <title>Java基础--内部类</title>
      <link>https://wawazhua.cn/post/java/basic/java-innerclass/</link>
      <pubDate>Mon, 16 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-innerclass/</guid>
      <description>普通内部类 如果一个类只需要在另一个类内部使用，可以考虑将它写成内部类。 内部类拥有其外部类所有成员的访问权，因为内部类中隐含了一个外部类的引用</description>
    </item>
    
    <item>
      <title>Java基础--比较器Comparator</title>
      <link>https://wawazhua.cn/post/java/basic/java-comparator/</link>
      <pubDate>Sun, 15 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-comparator/</guid>
      <description>Comparable接口和Comparator接口都是用来定义集合中的排序的，只是Comparable是在集合内部定义排序的实现，Compa</description>
    </item>
    
    <item>
      <title>Java基础--CountDownLatch</title>
      <link>https://wawazhua.cn/post/java/basic/java-countdownlatch/</link>
      <pubDate>Sat, 14 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-countdownlatch/</guid>
      <description>CountDownLatch是线程同步辅助类，它允许一个或多个线程wait直到countdown被调用使count为0。 CountDownL</description>
    </item>
    
    <item>
      <title>Java基础--虚拟机JVM</title>
      <link>https://wawazhua.cn/post/java/basic/java-jvm/</link>
      <pubDate>Fri, 13 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-jvm/</guid>
      <description>JVM内存结构 Heap Space: 堆内存(Heap Space)是由Young Generation和Old Generation组成，而Young Generat</description>
    </item>
    
    <item>
      <title>Java-压缩解压gz</title>
      <link>https://wawazhua.cn/post/java/basic/java-blockingqueue/</link>
      <pubDate>Wed, 11 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-blockingqueue/</guid>
      <description>ArrayBlockingQueue是阻塞队列的一种，基于数组实现，长度固定，队尾添加，队首获取， 构造函数: ArrayBlockingQueue(int capacity) ArrayBlockingQueue(int capacity, boolean fair) ArrayBlockingQueue(int capacity, boolean fair, Collection&amp;lt;? extends E&amp;gt; c) 其中</description>
    </item>
    
    <item>
      <title>Java基础--反射Reflection</title>
      <link>https://wawazhua.cn/post/java/basic/java-reflection/</link>
      <pubDate>Mon, 09 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-reflection/</guid>
      <description>反射能在运行时获取一个类的全部信息，并且可以调用类方法，修改类属性，创建类实例。 而在编译期间不用关心对象是谁 反射可用在动态代理，注解解释，和</description>
    </item>
    
    <item>
      <title>Java基础--读写文件</title>
      <link>https://wawazhua.cn/post/java/basic/java-clone/</link>
      <pubDate>Sun, 08 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-clone/</guid>
      <description>对象拷贝用于在内存中复制对象，无需构造器便可创建对象。 需要注意的是 clone方法提供的只是简单的值拷贝和地址拷贝，若类中包含HashMap等</description>
    </item>
    
    <item>
      <title>Java基础--HashCode</title>
      <link>https://wawazhua.cn/post/java/basic/java-hashcode/</link>
      <pubDate>Sat, 07 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-hashcode/</guid>
      <description>如果一个类的对象要用做hashMap的key，那么一定要注意覆盖该类的equals和hashCode方法。 equals()是基类Object</description>
    </item>
    
    <item>
      <title>Java基础--序列化Serializable</title>
      <link>https://wawazhua.cn/post/java/basic/java-serializable/</link>
      <pubDate>Fri, 06 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-serializable/</guid>
      <description>对Java对象序列化的目的是持久化对象或者为RMI(远程方法调用)传递参数和返回值。 下面是一个序列化对象写入文件的例子: package utils; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException;</description>
    </item>
    
    <item>
      <title>Java基础--单例类</title>
      <link>https://wawazhua.cn/post/java/basic/java-singleton/</link>
      <pubDate>Thu, 05 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-singleton/</guid>
      <description>单例模式的主要作用是保证在Java程序中，某个类只有一个实例存在。单例模式有很多好处，它能够避免实例对象的重复创建，不仅可以减少每次创建对象</description>
    </item>
    
    <item>
      <title>Java基础--ThreadLocal</title>
      <link>https://wawazhua.cn/post/java/basic/java-threadlocal/</link>
      <pubDate>Wed, 04 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-threadlocal/</guid>
      <description>Java中的ThreadLocal 可以看做以线程标识为key的Map，在多线程开发中应用广泛。 示例 class ThreadEnv { // 用匿名内部类覆盖ThreadLoc</description>
    </item>
    
    <item>
      <title>Java基础--读写文件</title>
      <link>https://wawazhua.cn/post/java/basic/java-io/</link>
      <pubDate>Tue, 03 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-io/</guid>
      <description>Java读写文件需要注意异常的处理 写文件 public class WriteFile { public static void write(String file, String text){ try{ PrintWriter out = new PrintWriter(new File(file).getAbsoluteFile()); try{ out.print(text); }finally{ out.close(); } }catch(IOException e){ throw new RuntimeException(e); } } public static void main(String[] args) throws IOException{ String file = &amp;quot;test.txt&amp;quot;; //print current path System.out.println(new File(&amp;quot;&amp;quot;).getAbsolutePath()); String context = &amp;quot;i</description>
    </item>
    
    <item>
      <title>Java基础--压缩和解压缩gz包</title>
      <link>https://wawazhua.cn/post/java/basic/java-gz/</link>
      <pubDate>Mon, 02 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-gz/</guid>
      <description>gz是Linux和OSX中常见的压缩文件格式，下面是用java压缩和解压缩gz包的例子 public class GZIPcompress { public static void FileCompress(String file, String outgz) throws IOException { BufferedReader br = new BufferedReader(new FileReader(file)); BufferedOutputStream bs = new BufferedOutputStream(new GZIPOutputStream(new FileOutputStream(outgz)));</description>
    </item>
    
    <item>
      <title>Java基础--枚举Enum</title>
      <link>https://wawazhua.cn/post/java/basic/java-enum/</link>
      <pubDate>Sun, 01 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://wawazhua.cn/post/java/basic/java-enum/</guid>
      <description>Java中的枚举是一种特殊的类，可以将一组固定常量的集合组成一种类型，使用方便且类型安全。使用enum关键字定义。 enum类型父类为Enum</description>
    </item>
    
  </channel>
</rss>